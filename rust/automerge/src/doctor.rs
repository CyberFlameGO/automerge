use itertools::Itertools;

use crate::{
    clocks::Clocks,
    query,
    types::{Clock, ObjId, Op, OpId, OpIds},
    Automerge,
};

pub fn heal(doc: &mut Automerge) {
    for mismatch in pred_mismatches(doc) {
        let q = doc
            .ops()
            .search(&mismatch.obj, query::OpIdSearch::new(mismatch.op));
        doc.ops_mut()
            .change_vis(&mismatch.obj, q.index().unwrap(), |op| {
                op.pred = mismatch.expected_preds.clone();
            });
    }
}

fn pred_mismatches(doc: &crate::Automerge) -> Vec<Mismatch> {
    // An operation which sets a key which was previously set by a change in the depencies of the
    // change containing the operation but which does not have a `pred` is suspicious. There's no
    // way that such an operation would be generated by any well behaved library.
    //
    // scan through every op, building a list of operations which _should_ precede each op
    let clocks = doc.build_clocks();

    let mut keyops = Vec::new();
    let mut mismatches = Vec::new();
    for (obj, _typ, ops) in doc.ops().iter_objs() {
        let ops_by_key = ops.group_by(|o| o.key);
        for (_key, ops) in ops_by_key.into_iter() {
            keyops.clear();
            keyops.extend(ops);
            let this_key_mismatches = pred_mismatches_for_key(doc, obj, &clocks, &keyops);
            mismatches.extend(this_key_mismatches.clone());
        }
    }
    tracing::debug!("found {} mismatches", mismatches.len());
    mismatches
}

#[derive(Clone, Debug)]
pub struct Mismatch {
    op: OpId,
    obj: ObjId,
    expected_preds: OpIds,
    #[allow(dead_code)]
    actual_preds: OpIds,
}

struct PredSearch {
    /// The op we are trying to calculate preds for
    reference: OpId,
    /// The clock as at `self.reference`
    clock: Clock,
    /// The preds we think should have been set
    opids: OpIds,
}

impl PredSearch {
    fn new(reference: OpId, clock: Clock) -> Self {
        Self {
            reference,
            clock,
            opids: OpIds::empty(),
        }
    }

    /// Add `new_op` op to the preceding ops if it is not already transitively covered
    fn insert(&mut self, doc: &Automerge, new_op: OpId) {
        // This logic is currently pretty inadequate. We should be checking for whether `new_op`
        // was visible at the time that `self.reference` was inserted.
        if new_op == self.reference {
            return;
        }
        if (!self.clock.covers(&new_op)) && self.reference.actor() != new_op.actor() {
            return;
        }
        // At this point we know that `new_op` is somewhere in the past of `self.reference`
        for old_op in &self.opids {
            // Discard `new_op` if it is already covered by an existing op. We just have to check
            // counters because we know that everything in `self.opids` is in the past of
            // `self.reference`
            if old_op.counter() > new_op.counter() {
                return;
            }
        }
        if self.reference.counter() < new_op.counter() {
            return;
        }
        self.opids
            .add(new_op, |left, right| doc.ops().m.lamport_cmp(*left, *right));
    }
}

fn pred_mismatches_for_key(
    doc: &Automerge,
    obj: &ObjId,
    clocks: &Clocks,
    ops: &[&Op],
) -> Vec<Mismatch> {
    let mut mismatches = Vec::new();
    for op in ops.iter() {
        let change = doc.change_of(op.id).unwrap();
        let clock = clocks.for_op(&change.hash(), op.id).unwrap();
        let mut search = PredSearch::new(op.id, clock);
        for previous_op in ops.iter().rev() {
            search.insert(doc, previous_op.id);
        }
        if op.pred != search.opids {
            mismatches.push(Mismatch {
                obj: *obj,
                op: op.id,
                expected_preds: search.opids.clone(),
                actual_preds: op.pred.clone(),
            });
        }
    }
    mismatches
}
